#pragma once

#include <vector>
#include <map>
#include <string>
#include <queue>
#include <memory>

#include "event.h"
#include "data_handler.h"

class Strategy {
    /*
    Strategy is an abstract base class providing an interface for
    all subsequent (inherited) strategy handling objects.

    The goal of a (derived) Strategy object is to generate Signal
    objects for particular symbols based on the inputs of Bars 
    (OLHCVI) generated by a DataHandler object.

    This is designed to work both with historic and live data as
    the Strategy object is agnostic to the data source,
    since it obtains the bar vecotrs from a queue object.
    */
public:
    virtual ~Strategy() = default;

    // Provides mechanisms to calculate the list of signals.
    virtual void calculateSignals() = 0;
};

class BuyAndHoldStrategy : public Strategy {
    /*
    This is an extremely simple strategy that goes LONG all of the 
    symbols as soon as a bar is received. It will never exit a position.

    It is primarily used as a testing mechanism for the Strategy class
    as well as a benchmark upon which to compare other strategies.
    */
public:
    /*
    Parameters:
    bars - The DataHandler object that provides bar information
    events - The Event Queue object.
    */
    BuyAndHoldStrategy(DataHandler* data, std::queue<std::shared_ptr<Event>>& events);

    void calculateSignals() override;

private:
    DataHandler* data;
    std::queue<std::shared_ptr<Event>>& events;
    std::vector<std::string> symbolList; // Local copy good for caching purposes
    std::map<std::string, bool> boughtStatus;

    // Once buy & hold signal is given, these are set to True
    void calculateInitialBought();
};